
<!-- saved from url=(0054)http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>JavaScript AES Example</title>
<script language="JavaScript">
// sample key to expand:
//      2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c
// sample data:
//      32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34
// output:
//      39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32

// sample key/data:
// PLAINTEXT: 00112233445566778899aabbccddeeff
// KEY:       000102030405060708090a0b0c0d0e0f
// OUTPUT:    69c4e0d86a7b0430d8cdb78070b4c55a

// max  of parts we will have in our message
var PART_COUNT = 5;
// actual # used
var used_part_count;

// accumulate values to put into text area
var accumulated_output_info;

// add a labeled value to the text area
function accumulate_output( str )
{
   accumulated_output_info = accumulated_output_info + str + "\n";
}

// convert a 8-bit value to a string
function cvt_hex8( val )
{
   var vh = (val>>>4)&0x0f;
   return vh.toString(16) + (val&0x0f).toString(16);
}

// convert a 32-bit value to a 8-char hex string
function cvt_hex32( val )
{
   var str="";
   var i;
   var v;

   for( i=7; i>=0; i-- )
   {
      v = (val>>>(i*4))&0x0f;
      str += v.toString(16);
   }
   return str;
}

// convert a two-digit hex value to a number
function cvt_byte( str )
{
  // get the first hex digit
  var val1 = str.charCodeAt(0);

  // do some error checking
  if ( val1 >= 48 && val1 <= 57 )
      // have a valid digit 0-9
      val1 -= 48;
   else if ( val1 >= 65 && val1 <= 70 )
      // have a valid digit A-F
      val1 -= 55;
   else if ( val1 >= 97 && val1 <= 102 )
      // have a valid digit A-F
      val1 -= 87;
   else
   {
      // not 0-9 or A-F, complain
      window.alert( str.charAt(1)+" is not a valid hex digit" );
      return -1;
   }

  // get the second hex digit
  var val2 = str.charCodeAt(1);

  // do some error checking
  if ( val2 >= 48 && val2 <= 57 )
      // have a valid digit 0-9
      val2 -= 48;
   else if ( val2 >= 65 && val2 <= 70 )
      // have a valid digit A-F
      val2 -= 55;
   else if ( val2 >= 97 && val2 <= 102 )
      // have a valid digit A-F
      val2 -= 87;
   else
   {
      // not 0-9 or A-F, complain
      window.alert( str.charAt(2)+" is not a valid hex digit" );
      return -1;
   }

   // all is ok, return the value
   return val1*16 + val2;
}

// add a byte to the output
// add a byte to the output
function accumulate_byte( label, val )
{
   accumulated_output_info += label + cvt_hex8(val) + "\n";
}

// add an array to the output
function accumulate_array( label, ary )
{
   var i, j;

   accumulated_output_info += label;

   // build the table
   for( i=0; i<ary.length; i++ )
   {
      // put in each entry
      accumulated_output_info += " " + cvt_hex8( ary[i] );
   }
   accumulated_output_info += "\n";
}

// S-Box substitution table
var S_enc = new Array(
 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);

// inverse S-Box for decryptions
var S_dec = new Array(
 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);

// convert two-dimensional indicies to one-dim array indices
var I00 = 0;
var I01 = 1;
var I02 = 2;
var I03 = 3;
var I10 = 4;
var I11 = 5;
var I12 = 6;
var I13 = 7;
var I20 = 8;
var I21 = 9;
var I22 = 10;
var I23 = 11;
var I30 = 12;
var I31 = 13;
var I32 = 14;
var I33 = 15;
// conversion function for non-constant subscripts
// assume subscript range 0..3
function I(x,y)
{ return (x*4) + y; }

// remove spaces from input
function remove_spaces( instr )
{
   var i;
   var outstr="";

   for( i=0; i<instr.length; i++ )
      if ( instr.charAt(i) != " " )
         // not a space, include it
         outstr += instr.charAt(i);

   return outstr;
}

// get the message to encrypt/decrypt or the key
// return as a byte array
function get_value( str, isASCII, minByteLength )
{
   var dbyte = new Array(16);
   var i;
   var val;	// one hex digit

   if ( isASCII )
   {
      // check length of data
      if ( str.length < minByteLength || str.length > 16 )
      {
         window.alert("Message/key length wrong: Is " + str.length +
		"characters, but must be 128 bits (16 ASCII characters)");
         dbyte[0] = -1;
         return dbyte;
      }

      // have ASCII data
      for( i=0; i<16; i++ )
      {
         dbyte[i] = str.charCodeAt(i);
      }
   }
   else
   {
      // have hex data - remove any spaces they used, then convert
      str = remove_spaces(str);

      // check length of data
      if ( str.length < minByteLength*2 || str.length > 32 )
      {
         window.alert("Message/key length wrong: Is " + str.length +
		" hex digits, but must be 128 bits (32 hex digits)");
         dbyte[0] = -1;
         return dbyte;
      }

      for( i=0; i<16; i++ )
      {
         // isolate and convert this substring
         dbyte[i] = cvt_byte( str.substr(i*2,2) );
         if( dbyte[i] < 0 )
         {
            // have an error
            dbyte[0] = -1;
            return dbyte;
         }
      } // for i
   } // if isASCII

   // return successful conversion
   return dbyte;
} // get_value

//do the AES GF(2**8) multiplication
// do this by the shift-and-"add" approach
function aes_mul( a, b )
{
   var res = 0;

   while( a > 0 )
   {
      if ( a&1 )
         res = res ^ b;		// "add" to the result
      a >>>= 1;			// shift a to get next higher-order bit
      b <<= 1;			// shift multiplier also
   }

   // now reduce it modulo x**8 + x**4 + x**3 + x + 1
   var hbit = 0x10000;		// bit to test if we need to take action
   var modulus = 0x11b00;	// modulus - XOR by this to change value
   while( hbit >= 0x100 )
   {
      if ( res & hbit )		// if the high-order bit is set
         res ^= modulus;	// XOR with the modulus

      // prepare for the next loop
      hbit >>= 1;
      modulus >>= 1;
   }

   return res;
}

// apply the S-box substitution to the key expansion
function SubWord( word_ary )
{
   var i;

   for( i=0; i<16; i++ )
      word_ary[i] = S_enc[ word_ary[i] ];

   return word_ary;
}

// rotate the bytes in a word
function RotWord( word_ary )
{
   return new Array( word_ary[1], word_ary[2], word_ary[3], word_ary[0] );
}

// calculate the first item Rcon[i] = { x^(i-1), 0, 0, 0 }
// note we only return the first item
function Rcon( exp )
{
   var val = 2;
   var result = 1;

   // remember to calculate x^(exp-1)
   exp--;

   // process the exponent using normal shift and multiply
   while ( exp > 0 )
   {
      if ( exp & 1 )
         result = aes_mul( result, val );

      // square the value
      val = aes_mul( val, val );

      // move to the next bit
      exp >>= 1;
   }

   return result;
}

// round key generation
// return a byte array with the expanded key information
function key_expand( key )
{
   var temp = new Array(4);
   var i, j;
   var w = new Array( 4*11 );

   // copy initial key stuff
   for( i=0; i<16; i++ )
   {
      w[i] = key[i];
   }

   // generate rest of key schedule using 32-bit words
   i = 4;
   while ( i < 44 )		// blocksize * ( rounds + 1 )
   {
      // copy word W[i-1] to temp
      for( j=0; j<4; j++ )
         temp[j] = w[(i-1)*4+j];

      if ( i % 4 == 0)
      {
         // temp = SubWord(RotWord(temp)) ^ Rcon[i/4];
         temp = RotWord( temp );
         temp = SubWord( temp );
         temp[0] ^= Rcon( i>>>2 );
      }

      // word = word ^ temp
      for( j=0; j<4; j++ )
         w[i*4+j] = w[(i-4)*4+j] ^ temp[j];

      i++;
   }

   return w;
}

// do S-Box substitution
function SubBytes(state, Sbox)
{
   var i;

   for( i=0; i<16; i++ )
      state[i] = Sbox[ state[i] ];

   return state;
}

// shift each row as appropriate
function ShiftRows(state)
{
   var t0, t1, t2, t3;

   // top row (row 0) isn't shifted

   // next row (row 1) rotated left 1 place
   t0 = state[I10];
   t1 = state[I11];
   t2 = state[I12];
   t3 = state[I13];
   state[I10] = t1;
   state[I11] = t2;
   state[I12] = t3;
   state[I13] = t0;

   // next row (row 2) rotated left 2 places
   t0 = state[I20];
   t1 = state[I21];
   t2 = state[I22];
   t3 = state[I23];
   state[I20] = t2;
   state[I21] = t3;
   state[I22] = t0;
   state[I23] = t1;

   // bottom row (row 3) rotated left 3 places
   t0 = state[I30];
   t1 = state[I31];
   t2 = state[I32];
   t3 = state[I33];
   state[I30] = t3;
   state[I31] = t0;
   state[I32] = t1;
   state[I33] = t2;

   return state;
}

// inverset shift each row as appropriate
function InvShiftRows(state)
{
   var t0, t1, t2, t3;

   // top row (row 0) isn't shifted

   // next row (row 1) rotated left 1 place
   t0 = state[I10];
   t1 = state[I11];
   t2 = state[I12];
   t3 = state[I13];
   state[I10] = t3;
   state[I11] = t0;
   state[I12] = t1;
   state[I13] = t2;

   // next row (row 2) rotated left 2 places
   t0 = state[I20];
   t1 = state[I21];
   t2 = state[I22];
   t3 = state[I23];
   state[I20] = t2;
   state[I21] = t3;
   state[I22] = t0;
   state[I23] = t1;

   // bottom row (row 3) rotated left 3 places
   t0 = state[I30];
   t1 = state[I31];
   t2 = state[I32];
   t3 = state[I33];
   state[I30] = t1;
   state[I31] = t2;
   state[I32] = t3;
   state[I33] = t0;

   return state;
}

// process column info
function MixColumns(state)
{
   var col;
   var c0, c1, c2, c3;

   for( col=0; col<4; col++ )
   {
      c0 = state[I(0,col)];
      c1 = state[I(1,col)];
      c2 = state[I(2,col)];
      c3 = state[I(3,col)];

      // do mixing, and put back into array
      state[I(0,col)] = aes_mul(2,c0) ^ aes_mul(3,c1) ^ c2 ^ c3;
      state[I(1,col)] = c0 ^ aes_mul(2,c1) ^ aes_mul(3,c2) ^ c3;
      state[I(2,col)] = c0 ^ c1 ^ aes_mul(2,c2) ^ aes_mul(3,c3);
      state[I(3,col)] = aes_mul(3,c0) ^ c1 ^ c2 ^ aes_mul(2,c3);
   }

   return state;
}

// inverse process column info
function InvMixColumns(state)
{
   var col;
   var c0, c1, c2, c3;

   for( col=0; col<4; col++ )
   {
      c0 = state[I(0,col)];
      c1 = state[I(1,col)];
      c2 = state[I(2,col)];
      c3 = state[I(3,col)];

      // do inverse mixing, and put back into array
      state[I(0,col)] = aes_mul(0x0e,c0) ^ aes_mul(0x0b,c1)
			^ aes_mul(0x0d,c2) ^ aes_mul(0x09,c3);
      state[I(1,col)] = aes_mul(0x09,c0) ^ aes_mul(0x0e,c1)
			^ aes_mul(0x0b,c2) ^ aes_mul(0x0d,c3);
      state[I(2,col)] = aes_mul(0x0d,c0) ^ aes_mul(0x09,c1)
			^ aes_mul(0x0e,c2) ^ aes_mul(0x0b,c3);
      state[I(3,col)] = aes_mul(0x0b,c0) ^ aes_mul(0x0d,c1)
			^ aes_mul(0x09,c2) ^ aes_mul(0x0e,c3);
   }

   return state;
}

// insert subkey information
function AddRoundKey( state, w, base )
{
   var col;

   for( col=0; col<4; col++ )
   {
      state[I(0,col)] ^= w[base+col*4];
      state[I(1,col)] ^= w[base+col*4+1];
      state[I(2,col)] ^= w[base+col*4+2];
      state[I(3,col)] ^= w[base+col*4+3];
   }

   return state;
}

// return a transposed array
function transpose( msg )
{
   var row, col;
   var state = new Array( 16 );

   for( row=0; row<4; row++ )
      for( col=0; col<4; col++ )
         state[I(row,col)] = msg[I(col,row)];

   return state;
}

// do encrytion
// msg: 16-byte array with the message
// w:   array with expanded 44-word key
// returns a 16-element byte array
function aes_encrypt( msg, w )
{
   var state = new Array( 16 );			// working state
   var round;

   // initial state = message in columns (transposed from what we input)
   state = transpose( msg );

   // insert the round key
   state = AddRoundKey(state, w, 0);

   for( round=1; round<10; round++ )
   {
      state = SubBytes(state, S_enc);
      state = ShiftRows(state);
      state = MixColumns(state);
      // note here the spec uses 32-bit words, we are using bytes, so an extra *4
      state = AddRoundKey(state, w, round*4*4);
   }

   SubBytes(state, S_enc);
   ShiftRows(state);
   AddRoundKey(state, w, 10*4*4);

   // process output
   return transpose( state );
}

// do decryption
// msg: 16-byte array with the message
// w:   array with expanded 44-word key
// returns a 16-element byte array
function aes_decrypt( msg, w )
{
   var state = new Array( 16 );			// working state
   var round;

   // initial state = message
   state = transpose( msg );
   state = AddRoundKey(state, w, 10*4*4);

   for( round=9; round>=1; round-- )
   {
      state = InvShiftRows(state);
      state = SubBytes(state, S_dec);
      // display the round key - Transpose due to the way it is stored/used
      // note here the spec uses 32-bit words, we are using bytes, so an extra *4
      state = AddRoundKey(state, w, round*4*4);
      state = InvMixColumns(state);
   }

   InvShiftRows(state);
   SubBytes(state, S_dec);
   AddRoundKey(state, w, 0);

   // process output
   return transpose( state );
}

// xor the elements of two arrays together
function xor_array( a1, a2 )
{
   var i;
   var res = Array();

   for( i=0; i<a1.length; i++ )
      res[i] = a1[i] ^ a2[i];

   return res;
}

// "add to" the last byte of an array
function add_array( ary, amount )
{
   var i;
   var carry = amount;
   var temp;

   var res = Array();

   for( i=ary.length-1; i>=0; i-- )
   {
      temp = carry + ary[i];
      res[i] = temp & 0x0ff;
      carry = temp >>> 8;
   }

   return res;
}

// final AES state (array of arrays)
var AES_output;

// format a single AES block, return the resulting string
function format_AES_block( blockval )
{
   var i;
   var bits;
   var str="";

   // what type of data do we have to work with?
   if ( document.stuff.outtype[0].checked )
   {
      // convert each set of bits back to ASCII
      for( i=0; i<blockval.length; i++ )
         str += String.fromCharCode( blockval[i] );
   }
   else 
   {
      // output hexdecimal data (insert spaces)
      for( i=0; i<blockval.length; i++ )
      {
         str += cvt_hex8( blockval[i] ) + " ";
      }
   }

   // copy to textbox
   return str;
}

// format AES output
// -- uses the global arrays AES_outputX
function format_AES_output( used_part_count )
{
   document.stuff.outdata1.value = format_AES_block( AES_output[0] );
   if ( used_part_count >= 2 )
      document.stuff.outdata2.value = format_AES_block( AES_output[1] );
   else
      document.stuff.outdata2.value = "";
   
   if ( used_part_count >= 3 )
      document.stuff.outdata3.value = format_AES_block( AES_output[2] );
   else
      document.stuff.outdata3.value = "";
   
   if ( used_part_count >= 4 )
      document.stuff.outdata4.value = format_AES_block( AES_output[3] );
   else
      document.stuff.outdata4.value = "";
   
   if ( used_part_count >= 5 )
      document.stuff.outdata5.value = format_AES_block( AES_output[4] );
   else
      document.stuff.outdata5.value = "";
}

// encrypt a set of blocks using the designated chaining mode
function aes_chain_encrypt()
{
   var w = new Array( 44 );	// subkey information
   var state;			// working state
   var i;			// counter

   // clear debugging info
   accumulated_output_info = "";

   // set up new input and output data arrays
   var msg = new Array( PART_COUNT );
   AES_output = new Array( PART_COUNT );

   // note the last three modes don't require full-length blocks
   var minlength=16;
   if ( document.stuff.modelist.selectedIndex >= 3 )
   {
      // these permit variable-length data units
      minlength = 1;
   }

   // how many of the blocks are actually used?
   used_part_count=1;
   
   // get the message from the user
   // also check if it is ASCII or hex
   msg[0] = get_value( document.stuff.indata1.value,
			document.stuff.intype[0].checked, minlength );
	if ( document.stuff.indata2.value.length >  0 )
	{
	   used_part_count = 2;
      msg[1] = get_value( document.stuff.indata2.value,
            document.stuff.intype[0].checked, minlength );
            
      // only check box 2 if box 1 has something in it
      if ( document.stuff.indata3.value.length >  0 )
      {
         used_part_count = 3;
         msg[2] = get_value( document.stuff.indata3.value,
               document.stuff.intype[0].checked, minlength );

         if ( document.stuff.indata4.value.length >  0 )
         {
            used_part_count = 4;
            msg[3] = get_value( document.stuff.indata4.value,
                  document.stuff.intype[0].checked, minlength );
	
            if ( document.stuff.indata5.value.length >  0 )
            {
               used_part_count = 5;
               msg[4] = get_value( document.stuff.indata5.value,
                     document.stuff.intype[0].checked, minlength );
            }
         }
      }
   }

   // problems??
   for( i=0; i<used_part_count; i++ )
   {
      if ( msg[i][0] < 0 )
      {
         document.stuff.details.value = accumulated_output_info;
         return;
      }
   }

   // get the initial vector if we need it
   if ( document.stuff.modelist.selectedIndex != 0 )
   {
      var iv = get_value( document.stuff.initvec.value, false, 16 );
      // problems??
      if ( iv[0] < 0 )
      {
         document.stuff.details.value = accumulated_output_info;
         return;
      }
      accumulate_array( "Initialization vector", iv );
   }

   // get the key from the user
   var key = get_value( document.stuff.key.value, false, 16 );
   // problems??
   if ( key[0] < 0 )
   {
      document.stuff.details.value = accumulated_output_info;
      return;
   }
   accumulate_array( "Key", key );

   // expand the key
   w = key_expand( key );

   switch( document.stuff.modelist.selectedIndex )
   {
     case 0: 		// Electronic Code Book
         for( i=0; i<used_part_count; i++ )
         {
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = aes_encrypt( msg[i], w );
            accumulate_array( "Ciphertext part " + (i+1), AES_output[i] );
         }
         break;

      case 1: 		// Cipher Block Chaining
         // XOR initial vector and first data block, then encrypt that
         state = iv;
         accumulate_array( "Initial Vector", state );
         for( i=0; i<used_part_count; i++ )
         {
            // XOR last block and next data block, then encrypt that
            accumulate_array( "Message part " + (i+1), msg[i] );
            state = xor_array( state, msg[i] );

            // now encipher that
            accumulate_array( "State xor message", state );
            state = aes_encrypt( state, w );

            // save the output for the next block
            accumulate_array( "Ciphertext message part " + (i+1), state );
            AES_output[i] = state;
         }
         break;

      case 2: 		// Cipher Feedback (block)
         state = iv;
         accumulate_array( "Initial Vector", state );
         for( i=0; i<used_part_count; i++ )
         {
            // encrypt last cipher block
            state = aes_encrypt( state, w );
            accumulate_array( "Encrypted state", state );

            // XOR that with the message
            accumulate_array( "Message part " + (i+1), msg[i] );
            state = xor_array( msg[i], state );

            // save the output for the next block
            accumulate_array( "Ciphertext part " + (i+1), state );
            AES_output[i] = state;
         }
         break;

      case 3: 		// Cipher Feedback (byte)
         // encrypt the each byte of the message separately
         var enc_state, j;
         state = iv;
         for( i=0; i<used_part_count; i++ )
         {
            // build the array
            AES_output[i] = new Array();

            // now encrypt the message
            for( j=0; j<msg[i].length; j++ )
            {
               // encrypt the current state to get the new state
               accumulate_array( "State", state );
               enc_state = aes_encrypt( state, w );
               accumulate_array( "Encrypted state", enc_state );

               // generate the current byte of output
               temp = msg[i][j] ^ enc_state[0];
               accumulate_byte( "Plaintext byte:", msg[i][j] );
               accumulate_byte( "Ciphertext byte:", temp );
               AES_output[i][j] = temp;

               // update the state by shifting in the new cipher byte
               state.shift();
               state.push( temp );
            }
         }
         break;

      case 4: 		// Output Feedback
         state = iv;
         for( i=0; i<used_part_count; i++ )
         {
            state = aes_encrypt( state, w );
            accumulate_array( "Encrypted state", state );
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = xor_array( msg[i], state );
            accumulate_array( "Encrypted part " + (i+1), AES_output[i] );
         }
         break;

      case 5: 		// Counter
         for( i=0; i<used_part_count; i++ )
         {
            state = add_array(iv, i);
            accumulate_array( "iv+"+i, state );
            state = aes_encrypt( state, w );
            accumulate_array( "Encrypted iv+"+i, state );
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = xor_array( msg[i], state );
            accumulate_array( "Encrypted part " + (i+1), AES_output[i] );
         }
         break;
   }

   format_AES_output( used_part_count );
   document.stuff.details.value = accumulated_output_info;
}

// decrypt a set of blocks using the designated chaining mode
function aes_chain_decrypt()
{
   var w = new Array( 44 );	// subkey information
   var state;			// working state
   var i, j;			// counter
   var enc_state;		// encrypted state

   // clear debugging info
   accumulated_output_info = "";

   // set up new input and output data arrays
   var msg = new Array( PART_COUNT );
   AES_output = new Array( PART_COUNT );

   // note the last three modes don't require full-length blocks
   var minlength=16;
   if ( document.stuff.modelist.selectedIndex >= 3 )
   {
      // these permit variable-length data units
      minlength = 1;
   }

   used_part_count=1;
   // get the message from the user
   // also check if it is ASCII or hex
   msg[0] = get_value( document.stuff.indata1.value,
			document.stuff.intype[0].checked, minlength );
	if ( document.stuff.indata2.value.length >  0 )
	{
	   used_part_count = 2;
      msg[1] = get_value( document.stuff.indata2.value,
            document.stuff.intype[0].checked, minlength );
            
      // only check box 2 if box 1 has something in it
      if ( document.stuff.indata3.value.length >  0 )
      {
         used_part_count = 3;
         msg[2] = get_value( document.stuff.indata3.value,
               document.stuff.intype[0].checked, minlength );

         if ( document.stuff.indata4.value.length >  0 )
         {
            used_part_count = 4;
            msg[3] = get_value( document.stuff.indata4.value,
                  document.stuff.intype[0].checked, minlength );
	
            if ( document.stuff.indata5.value.length >  0 )
            {
               used_part_count = 5;
               msg[4] = get_value( document.stuff.indata5.value,
                     document.stuff.intype[0].checked, minlength );
            }
         }
      }
   }

   // problems??
   for( i=0; i<used_part_count; i++ )
   {
      if ( msg[i][0] < 0 )
      {
         document.stuff.details.value = accumulated_output_info;
         return;
      }
   }

   // get the initial vector if we need it
   if ( document.stuff.modelist.selectedIndex != 0 )
   {
      var iv = get_value( document.stuff.initvec.value, false, 16 );
      // problems??
      if ( iv[0] < 0 )
      {
         document.stuff.details.value = accumulated_output_info;
         return;
      }
      accumulate_array( "Initialization vector", iv );
   }

   // get the key from the user
   var key = get_value( document.stuff.key.value, false, 16 );
   // problems??
   if ( key[0] < 0 )
   {
      document.stuff.details.value = accumulated_output_info;
      return;
   }
   accumulate_array( "Key", key );

   // expand the key
   w = key_expand( key );

   switch( document.stuff.modelist.selectedIndex )
   {
     case 0: 		// Electronic Code Book
         for( i=0; i<used_part_count; i++ )
         {
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = aes_decrypt( msg[i], w );
            accumulate_array( "Decrypted text part " + (i+1), AES_output[i] );
         }
         break;

      case 1: 		// Cipher Block Chaining
         // XOR initial vector and first data block, then encrypt that
         state = iv;
         accumulate_array( "Initial Vector", state );
         for( i=0; i<used_part_count; i++ )
         {
            // decipher this block
            enc_state = aes_decrypt( msg[i], w );
            accumulate_array( "Decrypted message part " + (i+1), enc_state );
            accumulate_array( "Previous ciphertext block", state );

            // XOR this with the last block/IV to get the plaintext
            AES_output[i] = xor_array( state, enc_state );
            accumulate_array( "Decrypted text part " + (i+1), AES_output[i] );

            // save the old ciphertext for the next block
            state = msg[i];
         }
         break;

      case 2: 		// Cipher Feedback (block)
         state = iv;
         accumulate_array( "Initial Vector", state );
         for( i=0; i<used_part_count; i++ )
         {
            // encrypt current state to get what we XOR with the ciphertext
            enc_state = aes_encrypt( state, w );
            accumulate_array( "Encrypted state", enc_state );

            // XOR that with the message
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = xor_array( msg[i], enc_state );

            // update the state
            state = msg[i];
         }
         break;

      case 3: 		// Cipher Feedback (byte)
         // encrypt the each byte of the message separately
         state = iv;
         for( i=0; i<used_part_count; i++ )
         {
            // build the array
            AES_output[i] = new Array();

            // now encrypt the message
            for( j=0; j<msg[i].length; j++ )
            {
               // encrypt the current state to get the new state
               accumulate_array( "State", state );
               enc_state = aes_encrypt( state, w );
               accumulate_array( "Encrypted state", enc_state );

               // generate the current byte of output
               temp = msg[i][j] ^ enc_state[0];
               accumulate_byte( "Ciphertext byte:", msg[i][j] );
               accumulate_byte( "Decrypted byte:", temp );
               AES_output[i][j] = temp;

               // update the state by shifting in the new cipher byte
               state.shift();
               state.push( msg[i][j] );
            }
         }
         break;

      case 4: 		// Output Feedback
         state = iv;
         for( i=0; i<used_part_count; i++ )
         {
            state = aes_encrypt( state, w );
            accumulate_array( "Encrypted state", state );
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = xor_array( msg[i], state );
            accumulate_array( "Decrypted part " + (i+1), AES_output[i] );
         }
         break;

      case 5: 		// Counter
         for( i=0; i<used_part_count; i++ )
         {
            state = add_array(iv, i);
            accumulate_array( "iv+"+i, state );
            state = aes_encrypt( state, w );
            accumulate_array( "Encrypted iv+"+i, state );
            accumulate_array( "Message part " + (i+1), msg[i] );
            AES_output[i] = xor_array( msg[i], state );
            accumulate_array( "Decrypted part " + (i+1), AES_output[i] );
         }
         break;
   }

   format_AES_output( used_part_count );
   document.stuff.details.value = accumulated_output_info;
}
</script>
</head>
<body>
This page illustrates the various modes of encryption.  These examples use the <a href="http://people.eku.edu/styere/Encrypt/JS-AES.html">AES</a> algorithm.
For most of the modes, the input blocks should be standard 128-bit AES blocks (16 characters or 32 hex digits).
Then you should enter the AES key and (if needed) an initialization vector (also 128 bits each).
Note that with modes that use an initialization vector, it is important that although the IV doesn't have to be
secret, it does have to be unique.  Two messages with the same IV can often be broken by working one message against
the other, even if the key remains unknown.

<p>
This page supports the following modes:
</p><ul>
   <li><a href="http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html#ECB">Electronic Codebook</a> - Each block is enciphered independently of the rest.  No initialization vector is used.</li>
   <li><a href="http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html#CBC">Cipher Block Chaining</a> - Each input block is exclusive-or'd with the ciphertext of the preceeding block before
being encrypted.
   </li><li><a href="http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html#CFB">Cipher Feedback</a> - This mode stores the initialization vector into a shift register.  To encipher a block, the current
contents of the shift register are enciphered, then exclusive-or'ed with the next plaintext block.  Then one or more bits of
the new ciphertext block are shifted into the shift register.
   </li><li><a href="http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html#OFB">Output Feedback</a> - The initialization vector is
enciphered using the specified block algorithm.  This is then exclusive-or'd with the message, and also saved to
encipher the next block.
   </li><li><a href="http://people.eku.edu/styere/Encrypt/JS-AES-Chain.html#CTR">Counter</a> - This mode sets a counter to the value of the initialization vector.  To encrypt a block,
the current counter is enciphered using the block algorithm.  The result is then exclusive-or'd with
the first part of the message.  The counter is then incremented in some way.
</li></ul>

<form name="stuff">
<i>10/27/06: I have decided to not allow the key to changed to reduce the chance of
this page being used to solve homework problems</i>
<table>
<tbody><tr>
	<td>Message Part 1:</td>
        <td><input type="text" name="indata1" size="50"></td>
</tr>
<tr>
	<td>Message Part 2:</td>
        <td><input type="text" name="indata2" size="50"></td>
</tr>
<tr>
	<td>Message Part 3:</td>
        <td><input type="text" name="indata3" size="50"></td>
</tr>
<tr>
	<td>Message Part 4:</td>
        <td><input type="text" name="indata4" size="50"></td>
</tr>
<tr>
	<td>Message Part 5:</td>
        <td><input type="text" name="indata5" size="50"></td>
</tr>
<tr>
	<td colspan="2" align="center">
            <input type="radio" name="intype">ASCII
            <input type="radio" name="intype" checked="">Hexadecimal
		</td>
</tr>
<tr><td>&nbsp;</td><td></td></tr>
<tr>
	<td>Initialization Vector</td>
        <td><input type="text" name="initvec" value="d1671e68ea1f0f231918309301d36a49" size="50"></td>
</tr>
<tr>
	<td>Key</td>
        <td><input type="text" name="key" value="0f1571c947d9e8590cb7add6af7f6798" readonly="" size="50"></td>
</tr>
<tr>
	<td colspan="2" align="center">
            Cipher Mode:
            <select name="modelist">
                <option>Electronic Codebook</option>
                <option>Cipher Block Chaining</option>
                <option>Cipher Feedback (by blocks)</option>
                <option>Cipher Feedback (by bytes)</option>
                <option>Output Feedback</option>
                <option>Counter</option>
            </select></td>
</tr>
<tr>
	<td colspan="2" align="center">
	    <input type="button" value="Encrypt" onclick="aes_chain_encrypt();">
	    <input type="button" value="Decrypt" onclick="aes_chain_decrypt();">
		</td>
</tr>
<tr><td>&nbsp;</td><td></td></tr>
<tr>
	<td>Output Part 1</td>
	<td><input type="text" name="outdata1" size="50"></td>
</tr>
<tr>
	<td>Output Part 2</td>
	<td><input type="text" name="outdata2" size="50"></td>
</tr>
<tr>
	<td>Output Part 3</td>
	<td><input type="text" name="outdata3" size="50"></td>
</tr>
<tr>
	<td>Output Part 4</td>
	<td><input type="text" name="outdata4" size="50"></td>
</tr>
<tr>
	<td>Output Part 5</td>
	<td><input type="text" name="outdata5" size="50"></td>
</tr>
<tr>
	<td colspan="2" align="center">
            <input type="radio" name="outtype" onclick="format_AES_output(used_part_count);">ASCII
            <input type="radio" name="outtype" checked="" onclick="format_AES_output(used_part_count);">Hexadecimal
		</td>
</tr>
</tbody></table>
<hr>
Details:<br>
<textarea name="details" id="details" rows="25" cols="90"></textarea>
</form>
<p>
</p><hr>
<p>
</p><h2>Decription of each of the modes</h2><p>
<a name="ECB"></a>
</p><h3>Electronic Codebook</h3>
Each block is enciphered independently of the rest.  No initialization vector is used.
<p>Encipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/ECB_enc.gif"><br></center>
<p>Decipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/ECB_dec.gif"><br></center>
<p>
One major weakness of ECB is that identical blocks of data are encrypted to the same blocks.
<a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">Wikipedia</a> has a nice example where
an image is encrypted using ECB, but the encrypted version can still be recognized.
</p><p>

<a name="CBC"></a>
</p><h3>Cipher Block Chaining</h3>
Each input block is exclusive-or'd with the ciphertext of the preceding block before
being encrypted.  This means that we now need an initialization vector.
It also that identical blocks no longer encrypt to the same data, since the IV/previous block will be different.
The initialization vector need not be secret, but must be unique to each message
<p>Encipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CBC_enc.gif"><br></center>
<p>Decipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CBC_dec.gif"><br></center>
<p>

<a name="CFB"></a>
</p><h3>Cipher Feedback</h3>
This mode stores the initialization vector into a shift register.  To encipher a block, the current
contents of the shift register are enciphered, then exclusive-or'ed with the next plaintext block.
Then one or more (possibly all) bits of
the new ciphertext block are shifted into the shift register.  That value is then enciphered and used for
the next block in the message.  
<p>Encipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CFB_enc.gif"><br></center>
<p>Decipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CFB_dec.gif"><br></center>
<p>

<a name="OFB"></a>
</p><h3>Output Feedback</h3>
This method converts a block cipher into a stream cipher.  The initialization vector is
enciphered using the specified block algorithm.  This is then exclusive-or'd with the message, and also saved to
encipher the next block.
One advantage of this
mode is that the message unit sizes don't have to match the encryption algorihtm, and can even vary in size.
For example, a 128-bit AES algorithm can be used to encrypt a series of 16-bit messages.
Futhermore, encryption and decryption become identical (only the encipher function of the underlying block
cipher is used), simplifying the implementation.
<p>Encipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/OFB_enc.gif"><br></center>
<p>Decipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/OFB_dec.gif"><br></center>
<p>
This mode gives a simple illustration why the initialization vectors must be unique.
Suppose I encipher two messages <i>M<sub>1</sub></i> and <i>M<sub>2</sub></i> with the same IV, resulting in the
ciphertexts <i>C<sub>1</sub></i> and <i>C<sub>2</sub></i>.
If an enemy can get both <i>C<sub>1</sub></i> and <i>C<sub>2</sub></i>, it
it simple to calculate <i>C<sub>1</sub> xor C<sub>2</sub></i>,
resulting in <i>M<sub>1</sub> xor M<sub>2</sub></i>.
With the encryption function out of the way, determing
<i>M<sub>1</sub></i> and <i>M<sub>2</sub></i> from each other (especially if one or both represent
ASCII text) is fairly simple.
</p><p>

<a name="CTR"></a>
</p><h3>Counter</h3>
This mode sets a counter to the value of the initialization vector.  To encrypt a block,
the current counter is enciphered using the block algorithm.  The result is then exclusive-or'd with
the first part of the message.  The counter is then incremented
(typically by adding 1, but other methods can be used).
The new IV is then used to encrypt the next part of the message.
This method is very useful for encrypting files, since it
is easy to decrypt data in the middle of the file.
All you need to do is determine the appropriate value for the counter (such as <i>IV+n</i>), and you
can skip directly to the part of the file you want to decrypt.
This mode also has most of the advantages of the Output Feedback mode.
<p>Encipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CTR_enc.gif"><br></center>
<p>Decipherment can be diagrammed as:<br>
</p><center><img src="./JavaScript AES-Chain Example_files/CTR_dec.gif"><br></center>

<hr>
Return to my <a href="http://people.eku.edu/styere/index.html">home page</a><br>
Go to the <a href="http://www.cs.eku.edu/">EKU CS Department</a> page


</body></html>